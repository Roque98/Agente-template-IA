# 🔧 Tools SQL con Parámetros - Configuración Completa

Este documento muestra cómo configurar las tools SQL usando el nuevo sistema de parámetros con gestión de contexto.

## 📋 Configuración de las Tools

### 1. Tool: Database Schema Provider

```json
{
    "name": "Database Schema Provider",
    "description": "Provides detailed database schema information including table descriptions, column details, relationships, and business context for SQL query generation",
    "endpoint_template": "http://localhost:5000/api/schema/info",
    "method_allowed": "GET",
    "auth_type": "bearer",
    
    "parameter_schema": {
        "required": [],
        "optional": ["include_samples", "include_relationships", "include_stats", "table_filter"],
        "properties": {
            "include_samples": {
                "type": "boolean",
                "description": "Include sample values for columns",
                "source": "default",
                "default": true,
                "business_meaning": "Helps agent understand data patterns"
            },
            "include_relationships": {
                "type": "boolean", 
                "description": "Include foreign key relationships between tables",
                "source": "default",
                "default": true,
                "business_meaning": "Essential for generating JOIN queries"
            },
            "include_stats": {
                "type": "boolean",
                "description": "Include table statistics like row counts",
                "source": "default",
                "default": false,
                "business_meaning": "Helps with query performance planning"
            },
            "table_filter": {
                "type": "string",
                "description": "Regex pattern to filter specific tables",
                "source": "agent_optional",
                "validation": "regex_pattern",
                "business_meaning": "Focus on relevant tables for specific domains"
            },
            "user_access_level": {
                "type": "string",
                "description": "User permission level for schema filtering",
                "source": "context",
                "context_path": "user.role",
                "business_meaning": "Filter sensitive tables based on user permissions"
            },
            "database_context": {
                "type": "string",
                "description": "Database environment context",
                "source": "fixed",
                "value": "production",
                "business_meaning": "Ensures we're pointing to correct database"
            }
        }
    },
    
    "fixed_parameters": {
        "api_version": "1.0",
        "response_format": "json",
        "cache_enabled": true,
        "max_tables": 50
    },
    
    "auth_parameters": {
        "token_source": "system_config",
        "encrypted_token": "encrypted_jwt_token_here"
    },
    
    "parameter_mapping": {
        "include_samples": "samples",
        "include_relationships": "relations", 
        "include_stats": "statistics",
        "table_filter": "filter",
        "user_access_level": "access_level",
        "database_context": "env"
    },
    
    "default_headers": {
        "Content-Type": "application/json",
        "Accept": "application/json",
        "X-Request-Source": "agent-system"
    },
    
    "timeout_seconds": 15,
    "rate_limit_per_minute": 30,
    "is_active": true
}
```

### 2. Tool: SQL Query Executor

```json
{
    "name": "SQL Query Executor", 
    "description": "Executes SQL SELECT queries against the database with comprehensive safety validations, user context, and performance monitoring",
    "endpoint_template": "http://localhost:5000/api/sql/execute",
    "method_allowed": "POST",
    "auth_type": "bearer",
    
    "parameter_schema": {
        "required": ["query"],
        "optional": ["limit", "timeout", "safe_mode", "explain_plan"],
        "properties": {
            "query": {
                "type": "string",
                "description": "SQL SELECT query to execute",
                "source": "agent_generated",
                "validation": "sql_select_only",
                "max_length": 5000,
                "business_meaning": "The actual SQL query generated by the agent based on user questions"
            },
            "limit": {
                "type": "integer",
                "description": "Maximum number of rows to return",
                "source": "agent_optional",
                "default": 1000,
                "min": 1,
                "max": 10000,
                "business_meaning": "Prevents overwhelming responses and controls performance"
            },
            "timeout": {
                "type": "integer",
                "description": "Query execution timeout in seconds",
                "source": "context_or_default",
                "context_path": "user.preferences.query_timeout",
                "default": 30,
                "min": 5,
                "max": 120,
                "business_meaning": "Prevents long-running queries from blocking the system"
            },
            "safe_mode": {
                "type": "boolean",
                "description": "Enable comprehensive safety validations",
                "source": "fixed",
                "value": true,
                "business_meaning": "Always enabled to prevent dangerous operations"
            },
            "explain_plan": {
                "type": "boolean",
                "description": "Return query execution plan for performance analysis",
                "source": "user_preference",
                "preference_key": "show_execution_plans",
                "default": false,
                "business_meaning": "Helps with query optimization and debugging"
            },
            "user_id": {
                "type": "string",
                "description": "ID of the user executing the query",
                "source": "context",
                "context_path": "user.id",
                "business_meaning": "For audit logging and permission checking"
            },
            "conversation_id": {
                "type": "string",
                "description": "UUID of the current conversation",
                "source": "context",
                "context_path": "conversation.uuid",
                "business_meaning": "Links query to conversation for context tracking"
            },
            "agent_id": {
                "type": "string", 
                "description": "ID of the agent making the request",
                "source": "context",
                "context_path": "agent.id",
                "business_meaning": "For tracking which agent generated the query"
            },
            "query_purpose": {
                "type": "string",
                "description": "Business purpose of the query",
                "source": "agent_generated",
                "validation": "non_empty",
                "business_meaning": "Helps with audit and understanding query intent"
            },
            "database_connection": {
                "type": "string",
                "description": "Database connection identifier",
                "source": "fixed",
                "value": "main_production_db",
                "business_meaning": "Ensures queries run against correct database"
            }
        }
    },
    
    "fixed_parameters": {
        "api_version": "1.0",
        "request_source": "agent_system",
        "enable_logging": true,
        "return_metadata": true
    },
    
    "auth_parameters": {
        "token_source": "system_config",
        "encrypted_token": "encrypted_jwt_token_for_sql_service"
    },
    
    "parameter_mapping": {
        "query": "sql_query",
        "limit": "max_rows",
        "timeout": "timeout_seconds", 
        "safe_mode": "enable_safety_checks",
        "explain_plan": "include_execution_plan",
        "user_id": "requesting_user_id",
        "conversation_id": "conversation_uuid",
        "agent_id": "source_agent_id",
        "query_purpose": "business_purpose",
        "database_connection": "db_connection_id"
    },
    
    "default_headers": {
        "Content-Type": "application/json",
        "Accept": "application/json",
        "X-Request-Source": "agent-system",
        "X-Safety-Mode": "enabled"
    },
    
    "timeout_seconds": 45,
    "rate_limit_per_minute": 20,
    "is_active": true
}
```

## 🔄 Flujo de Ejecución Completo

### 1. Usuario Inicia Conversación

```bash
# POST /api/v1/agents/1/execute
{
    "input_message": "¿Cuántos usuarios administrativos tenemos que se registraron este año?",
    "conversation_id": null  # Nueva conversación
}
```

### 2. Sistema Procesa el Mensaje

```python
# El sistema:
# 1. Crea nueva conversación
conversation = context_service.get_or_create_conversation(
    user_id=current_user.id,
    agent_id=1
)

# 2. Extrae variables del mensaje
extracted_vars = context_service.extract_variables_from_message(
    "¿Cuántos usuarios administrativos tenemos que se registraron este año?"
)
# Resultado:
# {
#     'mentioned_entities': ['usuarios', 'administrativos'],
#     'time_references': ['este año'],
#     'question_type': 'count_query',
#     'filters': ['role=admin', 'created_this_year']
# }

# 3. Guarda mensaje del usuario
context_service.add_message(
    conversation_id=conversation.id,
    message_type="user",
    content="¿Cuántos usuarios administrativos tenemos que se registraron este año?",
    context_variables=extracted_vars
)
```

### 3. Agente Ejecuta Schema Tool

```python
# El agente automáticamente llama primero al Schema Provider
schema_result = await tool_service.execute_tool(
    tool_id=1,  # Database Schema Provider
    agent_context={
        "query_intent": "get user counts by role and date"
    },
    conversation_id=conversation.id,
    user=current_user
)

# El sistema resuelve parámetros automáticamente:
resolved_params = {
    "include_samples": True,          # default
    "include_relationships": True,    # default  
    "include_stats": False,          # default
    "table_filter": None,            # no especificado
    "user_access_level": "Admin",    # de current_user.role
    "database_context": "production", # fixed parameter
    "api_version": "1.0",            # fixed parameter
    "response_format": "json",       # fixed parameter
    "cache_enabled": True            # fixed parameter
}

# HTTP Request generado:
# GET http://localhost:5000/api/schema/info?samples=true&relations=true&statistics=false&access_level=Admin&env=production
# Headers: Authorization: Bearer {token}, Content-Type: application/json, X-Request-Source: agent-system
```

### 4. Agente Genera SQL Query

```python
# Basado en el schema recibido, el agente genera:
generated_query = """
SELECT COUNT(*) as admin_users_this_year
FROM users 
WHERE role = 'Admin' 
  AND is_active = 1 
  AND YEAR(created_at) = YEAR(GETDATE())
"""

query_purpose = "Count active admin users registered in current year"
```

### 5. Agente Ejecuta Query Tool

```python
# El agente llama al SQL Query Executor
query_result = await tool_service.execute_tool(
    tool_id=2,  # SQL Query Executor
    agent_context={
        "query": generated_query,
        "query_purpose": query_purpose,
        "limit": 100  # No necesita muchas filas para un COUNT
    },
    conversation_id=conversation.id,
    user=current_user
)

# El sistema resuelve parámetros:
resolved_params = {
    "query": "SELECT COUNT(*) as admin_users_this_year FROM users WHERE role = 'Admin' AND is_active = 1 AND YEAR(created_at) = YEAR(GETDATE())",
    "limit": 100,                           # de agent_context
    "timeout": 30,                          # default (no preference set)
    "safe_mode": True,                      # fixed parameter
    "explain_plan": False,                  # user preference default
    "user_id": "123",                       # de current_user.id
    "conversation_id": "uuid-1234-5678",   # de conversation.uuid
    "agent_id": "1",                        # de agent context
    "query_purpose": "Count active admin users registered in current year",
    "database_connection": "main_production_db", # fixed parameter
    "api_version": "1.0",                   # fixed parameter
    "enable_logging": True                  # fixed parameter
}

# HTTP Request generado:
# POST http://localhost:5000/api/sql/execute
# Body: {
#     "sql_query": "SELECT COUNT(*) as admin_users_this_year FROM users WHERE role = 'Admin' AND is_active = 1 AND YEAR(created_at) = YEAR(GETDATE())",
#     "max_rows": 100,
#     "timeout_seconds": 30,
#     "enable_safety_checks": true,
#     "include_execution_plan": false,
#     "requesting_user_id": "123",
#     "conversation_uuid": "uuid-1234-5678",
#     "source_agent_id": "1",
#     "business_purpose": "Count active admin users registered in current year",
#     "db_connection_id": "main_production_db"
# }
```

### 6. Sistema Registra Ejecución

```python
# Se guarda en tool_executions:
{
    "tool_id": 2,
    "execution_id": 456,
    "user_id": 123,
    "input_parameters": {
        "query": "...",
        "query_purpose": "..."
    },
    "resolved_parameters": {
        "sql_query": "...",
        "max_rows": 100,
        "timeout_seconds": 30,
        # ... todos los parámetros resueltos
    },
    "request_data": {
        # Datos enviados al endpoint HTTP
    },
    "response_data": {
        "success": true,
        "data": {
            "rows": [{"admin_users_this_year": 15}],
            "execution_time_ms": 234
        }
    },
    "status": "success",
    "execution_time_ms": 456
}
```

### 7. Agente Responde al Usuario

```python
# El agente guarda su respuesta en la conversación
context_service.add_message(
    conversation_id=conversation.id,
    message_type="assistant",
    content="Según los datos de la base de datos, tienes **15 usuarios administrativos** que se registraron este año...",
    context_variables={
        "query_executed": generated_query,
        "result_count": 15,
        "query_type": "count",
        "entities_queried": ["users"],
        "filters_applied": ["role=Admin", "active=true", "year=current"]
    },
    execution_id=456  # Link a la ejecución
)
```

## 🔄 Casos de Uso Avanzados

### 1. Parámetro Faltante - Solicitud al Usuario

```python
# Usuario: "Consulta el clima para la presentación"
# Tool Weather necesita parámetro "location" que no está en el contexto

weather_result = await tool_service.execute_tool(
    tool_id=3,  # Weather API
    agent_context={
        "purpose": "presentation_planning"
    },
    conversation_id=conversation.id,
    user=current_user
)

# Resultado:
{
    "success": False,
    "error": "missing_parameters",
    "missing_parameters": [
        {
            "name": "location",
            "description": "City name or coordinates for weather query",
            "prompt": "¿Para qué ciudad necesitas consultar el clima?",
            "validation": "non_empty",
            "examples": ["Madrid", "Barcelona", "New York"]
        }
    ],
    "message": "Para consultar el clima, necesito saber la ubicación."
}

# El agente responde:
# "Para consultar el clima para tu presentación, necesito saber la ubicación. ¿Para qué ciudad quieres consultar el clima?"
```

### 2. Parámetro del Contexto Conversacional

```python
# Conversación previa:
# Usuario: "Estoy planeando un evento en Madrid para el próximo viernes"
# Agente: "Excelente, ¿en qué puedo ayudarte con tu evento en Madrid?"

# Usuario: "¿Qué tiempo hará?"
# El sistema puede extraer "Madrid" del contexto previo

extracted_context = {
    "location_mentioned": "Madrid",
    "event_date": "próximo viernes",
    "context_entities": ["evento", "Madrid", "viernes"]
}

# La tool Weather puede usar location="Madrid" del contexto
weather_result = await tool_service.execute_tool(
    tool_id=3,
    agent_context={},
    conversation_id=conversation.id,
    user=current_user
)

# Se resuelve automáticamente:
# location = "Madrid" (del contexto conversacional)
```

### 3. Parámetros de Preferencias de Usuario

```python
# Usuario tiene preferencias guardadas:
user_preferences = {
    "weather_units": "metric",
    "date_format": "DD/MM/YYYY", 
    "query_timeout": 45,
    "show_execution_plans": True,
    "default_query_limit": 500
}

# Al ejecutar SQL Query Executor:
resolved_params = {
    "timeout": 45,          # de user.preferences.query_timeout
    "explain_plan": True,   # de user.preferences.show_execution_plans
    "limit": 500           # de user.preferences.default_query_limit
}

# Al ejecutar Weather API:
resolved_params = {
    "units": "metric"      # de user.preferences.weather_units
}
```

### 4. Parámetros de Configuración Encriptada

```python
# En la configuración de la tool:
"auth_parameters": {
    "token_source": "encrypted_config",
    "encrypted_token": "AES256:encrypted_jwt_token_here",
    "key_rotation_date": "2024-01-15"
}

# Al resolver parámetros:
decrypted_token = decrypt_config_value("encrypted_jwt_token_here")

# En el HTTP request:
headers = {
    "Authorization": f"Bearer {decrypted_token}",
    "Content-Type": "application/json"
}
```

## 📊 Monitoreo y Métricas

### 1. Dashboard de Uso de Tools

```sql
-- Top tools más usadas
SELECT 
    t.name,
    COUNT(*) as executions,
    AVG(te.execution_time_ms) as avg_time_ms,
    SUM(CASE WHEN te.status = 'success' THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as success_rate
FROM tool_executions te
JOIN tools t ON te.tool_id = t.id
WHERE te.created_at >= DATEADD(day, -30, GETDATE())
GROUP BY t.name
ORDER BY executions DESC;

-- Parámetros más problemáticos
SELECT 
    JSON_VALUE(te.input_parameters, '$.missing_parameters[0].name') as missing_param,
    COUNT(*) as missing_count
FROM tool_executions te
WHERE te.status = 'error' 
  AND JSON_VALUE(te.error_message, '$.error') = 'missing_parameters'
GROUP BY JSON_VALUE(te.input_parameters, '$.missing_parameters[0].name')
ORDER BY missing_count DESC;
```

### 2. Análisis de Contexto Conversacional

```sql
-- Conversaciones más largas (mayor contexto)
SELECT 
    c.conversation_uuid,
    u.username,
    a.name as agent_name,
    COUNT(cm.id) as message_count,
    DATEDIFF(minute, c.started_at, c.last_message_at) as duration_minutes
FROM conversations c
JOIN users u ON c.user_id = u.id
JOIN agents a ON c.agent_id = a.id
JOIN conversation_messages cm ON c.id = cm.conversation_id
GROUP BY c.conversation_uuid, u.username, a.name, c.started_at, c.last_message_at
HAVING COUNT(cm.id) > 10
ORDER BY message_count DESC;

-- Variables más extraídas del contexto
SELECT 
    variable_key,
    COUNT(*) as extraction_count
FROM (
    SELECT JSON_QUERY(context_variables, '$') as vars
    FROM conversation_messages
    WHERE context_variables IS NOT NULL
) subq
CROSS APPLY OPENJSON(vars) WITH (variable_key NVARCHAR(100) '$')
GROUP BY variable_key
ORDER BY extraction_count DESC;
```

Este sistema de parámetros permite que las tools sean:

✅ **Inteligentes** - Resuelven parámetros automáticamente  
✅ **Contextuales** - Usan historial de conversación  
✅ **Seguras** - Encriptan credenciales sensibles  
✅ **Flexibles** - Diferentes fuentes de parámetros  
✅ **Auditables** - Registran toda la actividad  
✅ **User-friendly** - Solicitan input cuando es necesario  

¡El agente SQL ahora tendrá contexto completo y podrá manejar conversaciones naturales! 🚀